<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="虽然说自己已经可以用lean4写一些数学证明了，但是关于lean4语言本身还缺乏一些基础的认识。本文是与Gemini 3对话的内容，受益良多。\n在Lean4中命题即类型，证明命题即构造具有对应类型的项（柯里-霍华德同构）。如何理解 这是一个非常深刻且美妙的概念。理解“命题即类型（Propositions as Types）”和“证明即程序（Proofs as Programs）”是掌握 Lean 4 的核心。\n简单来说，在 Lean 中，写数学证明和写计算机程序本质上是同一件事。\n我们可以通过以下几个层次来拆解这个概念（即柯里-霍华德同构 Curry-Howard Isomorphism）：\n1. 核心类比表 首先，我们需要建立一个心理映射表：\n逻辑/数学领域 (Logic) 编程/类型论领域 (Programming) Lean 4 中的体现 命题 ($P$) 类型 ($T$) 1 + 1 = 2 是一个类型 证明 ($p$) 该类型的一个实例/值 ($t$) rfl 是上述类型的一个值 蕴含 ($P \\to Q$) 函数 (P -> Q) 一个接收 $P$ 并返回 $Q$ 的函数 全称量词 ($\\forall x, P(x)$) 依赖函数 (Dependent Function) 接收参数 $x$，返回类型随 $x$ 变化的函数 且 ($P \\land Q$) 积类型/结构体 (Product/Struct) 包含两个字段的结构体：(proof_of_P, proof_of_Q) 或 ($P \\lor Q$) 和类型/枚举 (Sum/Enum) 或者是 $P$ 的值，或者是 $Q$ 的值 假 ($\\text{False}$) 空类型 (Empty Type) 一个没有任何值的类型 (Void) 2. 详细解读 第一层：命题是什么？（Propositions as Types） 在传统编程中，类型通常是 Int, String, List。 在 Lean 中，数学陈述也是一种类型。\n"><title>基于Gemini 3的Lean4的一些理解</title><link rel=canonical href=https://bhjiang.pages.dev/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/><link rel=stylesheet href=/scss/style.min.b0e76e98cdd4f7082d1fc36f7af7e0843a81201db2197c03ca426751dc923735.css><meta property='og:title' content="基于Gemini 3的Lean4的一些理解"><meta property='og:description' content="虽然说自己已经可以用lean4写一些数学证明了，但是关于lean4语言本身还缺乏一些基础的认识。本文是与Gemini 3对话的内容，受益良多。\n在Lean4中命题即类型，证明命题即构造具有对应类型的项（柯里-霍华德同构）。如何理解 这是一个非常深刻且美妙的概念。理解“命题即类型（Propositions as Types）”和“证明即程序（Proofs as Programs）”是掌握 Lean 4 的核心。\n简单来说，在 Lean 中，写数学证明和写计算机程序本质上是同一件事。\n我们可以通过以下几个层次来拆解这个概念（即柯里-霍华德同构 Curry-Howard Isomorphism）：\n1. 核心类比表 首先，我们需要建立一个心理映射表：\n逻辑/数学领域 (Logic) 编程/类型论领域 (Programming) Lean 4 中的体现 命题 ($P$) 类型 ($T$) 1 + 1 = 2 是一个类型 证明 ($p$) 该类型的一个实例/值 ($t$) rfl 是上述类型的一个值 蕴含 ($P \\to Q$) 函数 (P -> Q) 一个接收 $P$ 并返回 $Q$ 的函数 全称量词 ($\\forall x, P(x)$) 依赖函数 (Dependent Function) 接收参数 $x$，返回类型随 $x$ 变化的函数 且 ($P \\land Q$) 积类型/结构体 (Product/Struct) 包含两个字段的结构体：(proof_of_P, proof_of_Q) 或 ($P \\lor Q$) 和类型/枚举 (Sum/Enum) 或者是 $P$ 的值，或者是 $Q$ 的值 假 ($\\text{False}$) 空类型 (Empty Type) 一个没有任何值的类型 (Void) 2. 详细解读 第一层：命题是什么？（Propositions as Types） 在传统编程中，类型通常是 Int, String, List。 在 Lean 中，数学陈述也是一种类型。\n"><meta property='og:url' content='https://bhjiang.pages.dev/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/'><meta property='og:site_name' content='滨宏'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='lean4'><meta property='article:tag' content='Gemini'><meta property='article:published_time' content='2025-11-29T00:00:00+00:00'><meta property='article:modified_time' content='2025-11-29T00:00:00+00:00'><meta property='og:image' content='https://bhjiang.pages.dev/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/lean4.png'><meta name=twitter:title content="基于Gemini 3的Lean4的一些理解"><meta name=twitter:description content="虽然说自己已经可以用lean4写一些数学证明了，但是关于lean4语言本身还缺乏一些基础的认识。本文是与Gemini 3对话的内容，受益良多。\n在Lean4中命题即类型，证明命题即构造具有对应类型的项（柯里-霍华德同构）。如何理解 这是一个非常深刻且美妙的概念。理解“命题即类型（Propositions as Types）”和“证明即程序（Proofs as Programs）”是掌握 Lean 4 的核心。\n简单来说，在 Lean 中，写数学证明和写计算机程序本质上是同一件事。\n我们可以通过以下几个层次来拆解这个概念（即柯里-霍华德同构 Curry-Howard Isomorphism）：\n1. 核心类比表 首先，我们需要建立一个心理映射表：\n逻辑/数学领域 (Logic) 编程/类型论领域 (Programming) Lean 4 中的体现 命题 ($P$) 类型 ($T$) 1 + 1 = 2 是一个类型 证明 ($p$) 该类型的一个实例/值 ($t$) rfl 是上述类型的一个值 蕴含 ($P \\to Q$) 函数 (P -> Q) 一个接收 $P$ 并返回 $Q$ 的函数 全称量词 ($\\forall x, P(x)$) 依赖函数 (Dependent Function) 接收参数 $x$，返回类型随 $x$ 变化的函数 且 ($P \\land Q$) 积类型/结构体 (Product/Struct) 包含两个字段的结构体：(proof_of_P, proof_of_Q) 或 ($P \\lor Q$) 和类型/枚举 (Sum/Enum) 或者是 $P$ 的值，或者是 $Q$ 的值 假 ($\\text{False}$) 空类型 (Empty Type) 一个没有任何值的类型 (Void) 2. 详细解读 第一层：命题是什么？（Propositions as Types） 在传统编程中，类型通常是 Int, String, List。 在 Lean 中，数学陈述也是一种类型。\n"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://bhjiang.pages.dev/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/lean4.png'><link rel="shortcut icon" href=/logo.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/logo_hu_bb3f348ef830ab8b.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>滨宏</a></h1><h2 class=site-description>知行合一</h2></div></header><ol class=menu-social><li><a href=https://github.com/heitopai target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#在lean4中命题即类型证明命题即构造具有对应类型的项柯里-霍华德同构如何理解>在Lean4中命题即类型，证明命题即构造具有对应类型的项（柯里-霍华德同构）。如何理解</a><ol><li><a href=#1-核心类比表>1. 核心类比表</a></li><li><a href=#2-详细解读>2. 详细解读</a><ol><li><a href=#第一层命题是什么propositions-as-types>第一层：命题是什么？（Propositions as Types）</a></li><li><a href=#第二层证明是什么proofs-as-terms>第二层：证明是什么？（Proofs as Terms）</a></li><li><a href=#第三层蕴含即函数implication-as-function>第三层：蕴含即函数（Implication as Function）</a></li><li><a href=#第四层全称量词与依赖类型forall-as-dependent-function>第四层：全称量词与依赖类型（$\forall$ as Dependent Function）</a></li></ol></li><li><a href=#3-一个完整的编程即证明演示>3. 一个完整的“编程即证明”演示</a></li><li><a href=#4-prop-与-type-的区别>4. Prop 与 Type 的区别</a></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#继续讲讲宇宙层级>继续讲讲“宇宙”层级</a><ol><li><a href=#1-什么是宇宙universe>1. 什么是宇宙（Universe）？</a><ol><li><a href=#第-0-级值-terms>第 0 级：值 (Terms)</a></li><li><a href=#第-1-级类型-types>第 1 级：类型 (Types)</a></li><li><a href=#第-2-级类型的类型-type-of-types>第 2 级：类型的类型 (Type of Types)</a></li><li><a href=#第-3-级及以上>第 3 级及以上</a></li></ol></li><li><a href=#2-prop-和-type两个平行的起点>2. Prop 和 Type：两个平行的起点</a><ol><li><a href=#分支一逻辑世界-prop--sort-0>分支一：逻辑世界 (<code>Prop</code> / <code>Sort 0</code>)</a></li><li><a href=#分支二数据世界-type--sort-1-sort-2>分支二：数据世界 (<code>Type</code> / <code>Sort 1</code>, <code>Sort 2</code>…)</a></li></ol></li><li><a href=#3-为什么要分层级罗素悖论>3. 为什么要分层级？（罗素悖论）</a></li><li><a href=#4-宇宙多态-universe-polymorphism>4. 宇宙多态 (Universe Polymorphism)</a></li><li><a href=#5-总结如何理解这张图谱>5. 总结：如何理解这张图谱</a></li></ol></li><li><a href=#讲讲tactics>讲讲tactics</a><ol><li><a href=#1-为什么我们需要-tactics>1. 为什么我们需要 Tactics？</a></li><li><a href=#2-核心机制tactic-mode-是如何工作的>2. 核心机制：Tactic Mode 是如何工作的？</a><ol><li><a href=#心理模型填坑游戏>心理模型：填坑游戏</a></li></ol></li><li><a href=#3-常见-tactics-与底层-term-的对应关系>3. 常见 Tactics 与底层 Term 的对应关系</a><ol><li><a href=#场景-1引入假设-intro>场景 1：引入假设 (<code>intro</code>)</a></li><li><a href=#场景-2应用定理-apply>场景 2：应用定理 (<code>apply</code>)</a></li><li><a href=#场景-3精确匹配-exact>场景 3：精确匹配 (<code>exact</code>)</a></li><li><a href=#场景-4结构分解-cases--rcases>场景 4：结构分解 (<code>cases</code> / <code>rcases</code>)</a></li></ol></li><li><a href=#4-实例演示两种模式的对比>4. 实例演示：两种模式的对比</a><ol><li><a href=#方式-aterm-mode-直接构造>方式 A：Term Mode (直接构造)</a></li><li><a href=#方式-btactic-mode-交互式>方式 B：Tactic Mode (交互式)</a></li></ol></li><li><a href=#5-高级-tactics自动化武器>5. 高级 Tactics：自动化武器</a></li><li><a href=#6-总结如何看待-tactics>6. 总结：如何看待 Tactics</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/><img src=/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/lean4_hu_b8a74405d9cbfe45.png srcset="/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/lean4_hu_b8a74405d9cbfe45.png 800w, /p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/lean4_hu_1874e8d1998d109c.png 1600w" width=800 height=384 loading=lazy alt="Featured image of post 基于Gemini 3的Lean4的一些理解"></a></div><div class=article-details><header class=article-category><a href=/categories/lean4/>Lean4
</a><a href=/categories/gemini/>Gemini</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E5%9F%BA%E4%BA%8Egemini-3%E7%9A%84lean4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/>基于Gemini 3的Lean4的一些理解</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-11-29T00:00:00Z>Nov 29, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 7 分钟</time></div></footer></div></header><section class=article-content><p>虽然说自己已经可以用lean4写一些数学证明了，但是关于lean4语言本身还缺乏一些基础的认识。本文是与Gemini 3对话的内容，受益良多。</p><h2 id=在lean4中命题即类型证明命题即构造具有对应类型的项柯里-霍华德同构如何理解>在Lean4中命题即类型，证明命题即构造具有对应类型的项（柯里-霍华德同构）。如何理解</h2><p>这是一个非常深刻且美妙的概念。理解“命题即类型（Propositions as Types）”和“证明即程序（Proofs as Programs）”是掌握 Lean 4 的核心。</p><p>简单来说，在 Lean 中，<strong>写数学证明和写计算机程序本质上是同一件事</strong>。</p><p>我们可以通过以下几个层次来拆解这个概念（即<strong>柯里-霍华德同构 Curry-Howard Isomorphism</strong>）：</p><hr><h3 id=1-核心类比表>1. 核心类比表</h3><p>首先，我们需要建立一个心理映射表：</p><div class=table-wrapper><table><thead><tr><th style=text-align:left>逻辑/数学领域 (Logic)</th><th style=text-align:left>编程/类型论领域 (Programming)</th><th style=text-align:left>Lean 4 中的体现</th></tr></thead><tbody><tr><td style=text-align:left><strong>命题</strong> ($P$)</td><td style=text-align:left><strong>类型</strong> ($T$)</td><td style=text-align:left><code>1 + 1 = 2</code> 是一个类型</td></tr><tr><td style=text-align:left><strong>证明</strong> ($p$)</td><td style=text-align:left><strong>该类型的一个实例/值</strong> ($t$)</td><td style=text-align:left><code>rfl</code> 是上述类型的一个值</td></tr><tr><td style=text-align:left><strong>蕴含</strong> ($P \to Q$)</td><td style=text-align:left><strong>函数</strong> (<code>P -> Q</code>)</td><td style=text-align:left>一个接收 $P$ 并返回 $Q$ 的函数</td></tr><tr><td style=text-align:left><strong>全称量词</strong> ($\forall x, P(x)$)</td><td style=text-align:left><strong>依赖函数</strong> (Dependent Function)</td><td style=text-align:left>接收参数 $x$，返回类型随 $x$ 变化的函数</td></tr><tr><td style=text-align:left><strong>且</strong> ($P \land Q$)</td><td style=text-align:left><strong>积类型/结构体</strong> (Product/Struct)</td><td style=text-align:left>包含两个字段的结构体：<code>(proof_of_P, proof_of_Q)</code></td></tr><tr><td style=text-align:left><strong>或</strong> ($P \lor Q$)</td><td style=text-align:left><strong>和类型/枚举</strong> (Sum/Enum)</td><td style=text-align:left>或者是 $P$ 的值，或者是 $Q$ 的值</td></tr><tr><td style=text-align:left><strong>假</strong> ($\text{False}$)</td><td style=text-align:left><strong>空类型</strong> (Empty Type)</td><td style=text-align:left>一个没有任何值的类型 (Void)</td></tr></tbody></table></div><hr><h3 id=2-详细解读>2. 详细解读</h3><h4 id=第一层命题是什么propositions-as-types>第一层：命题是什么？（Propositions as Types）</h4><p>在传统编程中，类型通常是 <code>Int</code>, <code>String</code>, <code>List</code>。
在 Lean 中，数学陈述也是一种类型。</p><ul><li><strong>例子</strong>：<code>1 + 1 = 2</code>
在 Lean 中，这不只是一个布尔值（True/False），而是一个<strong>类型（Type）</strong>。<ul><li>如果这个命题是真的，那么这个类型里就<strong>存在</strong>至少一个“值”（term）。</li><li>如果这个命题是假的（比如 <code>1 + 1 = 3</code>），那么这个类型就是<strong>空的</strong>，你造不出任何属于这个类型的值。</li></ul></li></ul><h4 id=第二层证明是什么proofs-as-terms>第二层：证明是什么？（Proofs as Terms）</h4><p>要证明一个命题，你只需要构造出属于该类型的一个<strong>值</strong>。</p><ul><li><strong>代码示例</strong>：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=c1>-- 定义一个类型（命题）：p 是 &#34;1 + 1 = 2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>def</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=mi>2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 提供一个值（证明）：proof_of_p 是类型 p 的一个实例</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- rfl 是 &#34;reflexivity&#34;（自反性）的缩写，是证明等式的基本构造子</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>def</span><span class=w> </span><span class=n>proof_of_p</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w> </span><span class=n>rfl</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div>当你写下 <code>def</code> 或 <code>theorem</code> 时，编译器（Type Checker）会检查你等号右边的“值”是否真的属于冒号右边的“类型”。如果检查通过，证明就成立了。</li></ul><h4 id=第三层蕴含即函数implication-as-function>第三层：蕴含即函数（Implication as Function）</h4><p>这是最精彩的部分。逻辑上的“如果 A 成立，那么 B 成立”（$A \to B$），在编程中就是一个<strong>函数</strong>。</p><ul><li><p><strong>逻辑角度</strong>：给我一个 A 的证明，我就能推导出 B 的证明。</p></li><li><p><strong>编程角度</strong>：给我一个类型为 <code>A</code> 的参数，我就返回一个类型为 <code>B</code> 的值。</p></li><li><p><strong>代码示例</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=c1>-- 假设 P 和 Q 是两个命题</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>variable</span><span class=w> </span><span class=o>(</span><span class=n>P</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 这是一个证明：证明 &#34;如果 P 且 Q 为真，那么 P 为真&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 输入参数 h 的类型是 (P ∧ Q)，返回值类型是 P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>theorem</span><span class=w> </span><span class=n>extract_p</span><span class=w> </span><span class=o>(</span><span class=n>h</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>Q</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>h</span><span class=bp>.</span><span class=n>left</span><span class=w>  </span><span class=c1>-- 我们从结构体 h 中取出了左边的字段</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这完全等同于写一个函数，输入一个 Pair，返回 Pair 的第一个元素。</p></li></ul><h4 id=第四层全称量词与依赖类型forall-as-dependent-function>第四层：全称量词与依赖类型（$\forall$ as Dependent Function）</h4><p>全称量词 $\forall x, P(x)$ 的意思是：对于任意的 $x$，命题 $P(x)$ 都成立。</p><p>在编程中，这对应<strong>依赖函数（Dependent Function）</strong>。这是一种特殊的函数，其<strong>返回值的类型取决于输入参数的值</strong>。</p><ul><li><strong>代码示例</strong>：<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=c1>-- 证明：对于任意自然数 n，n = n</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 这是一个函数，输入一个具体的数字 n，返回 &#34;n = n&#34; 这个类型的证明</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>theorem</span><span class=w> </span><span class=n>self_equal</span><span class=w> </span><span class=o>(</span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Nat</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=bp>=</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>rfl</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div>调用 <code>self_equal 5</code> 会得到一个类型为 <code>5 = 5</code> 的证明（值）。</li></ul><hr><h3 id=3-一个完整的编程即证明演示>3. 一个完整的“编程即证明”演示</h3><p>让我们来看看著名的 <strong>Modus Ponens</strong>（肯定前件律）：
逻辑表述：如果已知 $P \to Q$ 且已知 $P$，则可以推出 $Q$。</p><p>在 Lean 中，这只是简单的<strong>函数调用</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=kn>variable</span><span class=w> </span><span class=o>(</span><span class=n>P</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- mp 是函数名</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- h1 是一个函数 (P -&gt; Q)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- h2 是一个值 (P)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 我们的目标是构造一个 Q 类型的值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>def</span><span class=w> </span><span class=n>mp</span><span class=w> </span><span class=o>(</span><span class=n>h1</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>Q</span><span class=o>)</span><span class=w> </span><span class=o>(</span><span class=n>h2</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>h1</span><span class=w> </span><span class=n>h2</span><span class=w>  </span><span class=c1>-- 将参数 h2 传给函数 h1，得到的结果就是 Q</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>理解关键</strong>：
你不是在“寻找”真理，你是在“组装”数据。</p><ul><li>既然 <code>h1</code> 是一个把 $P$ 变 $Q$ 的转换器；</li><li><code>h2</code> 是原料 $P$；</li><li>那么 <code>h1 h2</code> 自然就是产品 $Q$。</li></ul><h3 id=4-prop-与-type-的区别>4. Prop 与 Type 的区别</h3><p>虽然我们说命题即类型，但在 Lean 4 中，它们处于不同的“宇宙”层级：</p><ol><li><strong>Type (Sort 1)</strong>: 用于数据和计算。比如 <code>Nat</code>, <code>List Int</code>。我们要区分 <code>0</code> 和 <code>1</code>，因为它们在计算上是不同的数据。</li><li><strong>Prop (Sort 0)</strong>: 用于逻辑命题。比如 <code>1 = 1</code>, <code>2 > 1</code>。</li></ol><p><strong>为什么区分？（证明无关性 Proof Irrelevance）</strong></p><ul><li>对于数据（Type），我们关心它<strong>是哪个值</strong>（<code>3</code> 和 <code>4</code> 是不同的）。</li><li>对于命题（Prop），我们只关心它<strong>是否有证明</strong>，而不关心<strong>证明长什么样</strong>。<ul><li>例如：证明 <code>2 + 2 = 4</code>，你可以用手指头数，也可以用皮亚诺公理推导。在 Lean 眼里，这两个证明是等价的，只要证明了它是真的，它们就是相等的。运行时，Prop 类型的值会被擦除（即不需要占用内存），因为程序跑起来只需要知道逻辑是对的，不需要带着证明跑。</li></ul></li></ul><h3 id=总结>总结</h3><p>在 Lean 4 中理解这句话，你需要转变思维：</p><ol><li><strong>不要把证明看作文本推导</strong>，而要看作<strong>拼积木（构造数据）</strong>。</li><li><strong>定理（Theorem）</strong> 就是 <strong>函数签名（Function Signature）</strong>。</li><li><strong>证明过程（Proof）</strong> 就是 <strong>函数体（Function Body）</strong>。</li><li><strong>Q.E.D.</strong> 就是 <strong>编译通过（Type Check Passed）</strong>。</li></ol><p>当你被要求证明 $A \to B$ 时，不要想“为什么 A 能推出 B”，而要想“我手里有个 A 类型的数据，怎么把它加工成 B 类型的数据？”</p><h2 id=继续讲讲宇宙层级>继续讲讲“宇宙”层级</h2><p>这是一个非常重要的问题。如果说“命题即类型”是 Lean 的骨架，那么**宇宙（Universes）**就是防止这个骨架坍塌的地基。</p><p>在 Lean 中，你可能会经常看到编译报错提到 <code>Type u</code>、<code>Sort u</code> 或者 <code>universe level</code>，这就是涉及到宇宙层级了。</p><p>我们通过三个问题来理解它：<strong>是什么？为什么？怎么用？</strong></p><hr><h3 id=1-什么是宇宙universe>1. 什么是宇宙（Universe）？</h3><p>回想一下我们之前的定义：</p><ul><li><code>5</code> 是一个值，它的类型是 <code>Nat</code>。</li><li><code>rfl</code> 是一个证明，它的类型是 <code>1 = 1</code>。</li></ul><p>那么问题来了：<strong><code>Nat</code> 的类型是什么？<code>1 = 1</code> 的类型又是什么？</strong></p><p>在 Lean 中，类型本身也是一种“东西”，所以<strong>类型也有类型</strong>。我们把“类型的类型”称为 <strong>宇宙（Universe）</strong>。</p><p>Lean 的世界是一个无限向上的阶梯：</p><h4 id=第-0-级值-terms>第 0 级：值 (Terms)</h4><p>这是具体的数值或证明对象。</p><ul><li><code>5</code></li><li><code>"Hello"</code></li><li><code>[]</code> (空列表)</li></ul><h4 id=第-1-级类型-types>第 1 级：类型 (Types)</h4><p>这是第 0 级东西的容器。</p><ul><li><code>Nat</code> （包含 5）</li><li><code>String</code> （包含 &ldquo;Hello&rdquo;）</li><li><code>List Nat</code> （包含 []）</li></ul><h4 id=第-2-级类型的类型-type-of-types>第 2 级：类型的类型 (Type of Types)</h4><p>这是第 1 级东西的容器。</p><ul><li>在 Lean 中，<code>Nat</code> 的类型叫做 <code>Type</code> (实际上是 <code>Type 0</code>)。</li></ul><h4 id=第-3-级及以上>第 3 级及以上</h4><ul><li><code>Type 0</code> 的类型是 <code>Type 1</code>。</li><li><code>Type 1</code> 的类型是 <code>Type 2</code>。</li><li>&mldr;以此类推，直到无穷。</li></ul><p>用代码验证一下（你可以在 VS Code 中输入 <code>#check</code> 查看）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=bp>#</span><span class=n>check</span><span class=w> </span><span class=mi>5</span><span class=w>        </span><span class=c1>-- 输出: 5 : Nat</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=bp>#</span><span class=n>check</span><span class=w> </span><span class=n>Nat</span><span class=w>      </span><span class=c1>-- 输出: Nat : Type</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=bp>#</span><span class=n>check</span><span class=w> </span><span class=kt>Type</span><span class=w>     </span><span class=c1>-- 输出: Type : Type 1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=bp>#</span><span class=n>check</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=mi>1</span><span class=w>   </span><span class=c1>-- 输出: Type 1 : Type 2</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><hr><h3 id=2-prop-和-type两个平行的起点>2. Prop 和 Type：两个平行的起点</h3><p>虽然阶梯是无限向上的，但 Lean 的底层（地基）其实分成了<strong>两支</strong>。Lean 内部使用关键字 <code>Sort</code> 来统一表示这两个分支。</p><h4 id=分支一逻辑世界-prop--sort-0>分支一：逻辑世界 (<code>Prop</code> / <code>Sort 0</code>)</h4><ul><li><strong>定义</strong>：这是所有<strong>命题</strong>居住的宇宙。</li><li><strong>别名</strong>：<code>Prop</code> 实际上就是 <code>Sort 0</code> 的语法糖。</li><li><strong>特点</strong>：<ul><li><code>1 = 1</code> 的类型是 <code>Prop</code>。</li><li><code>2 > 3</code> 的类型是 <code>Prop</code>。</li><li><strong>证明无关性</strong>：在这个层级里，我们不关心“值”（证明）长什么样，只关心有没有。</li><li><strong>运行时擦除</strong>：编译成二进制程序时，<code>Prop</code> 里的所有内容都会被删掉，不占空间。</li></ul></li></ul><h4 id=分支二数据世界-type--sort-1-sort-2>分支二：数据世界 (<code>Type</code> / <code>Sort 1</code>, <code>Sort 2</code>&mldr;)</h4><ul><li><strong>定义</strong>：这是所有<strong>数据结构</strong>居住的宇宙。</li><li><strong>别名</strong>：<ul><li><code>Type 0</code> 是 <code>Sort 1</code> 的语法糖（通常简写为 <code>Type</code>）。</li><li><code>Type 1</code> 是 <code>Sort 2</code> 的语法糖。</li><li><code>Type u</code> 是 <code>Sort (u+1)</code> 的语法糖。</li></ul></li><li><strong>特点</strong>：<code>Nat</code>、<code>Bool</code>、<code>List</code> 都在这里。这里的“值”对计算结果很重要，不能删。</li></ul><hr><h3 id=3-为什么要分层级罗素悖论>3. 为什么要分层级？（罗素悖论）</h3><p>你可能会问：<em>“为什么要搞这么多 <code>Type 0</code>, <code>Type 1</code>&mldr; 为什么不直接规定 <code>Type</code> 的类型就是 <code>Type</code> 自己呢？”</em></p><p>如果允许 <code>Type : Type</code>（类型包含其自身），数学系统就会崩溃。这对应著名的 <strong>罗素悖论 (Russell&rsquo;s Paradox)</strong>。</p><p><strong>通俗解释：</strong>
想象有一本“书目大全”，它列出了图书馆里所有的书。</p><ul><li>问题：这就引出了一个悖论，这本“书目大全”应该把它自己列进去吗？</li><li>如果允许“集合包含自身”，你就可以构造一个“所有不包含自己的集合的集合”。这就导致了逻辑矛盾（如果是，则不是；如果不是，则是）。</li></ul><p>为了避免这个逻辑炸弹，Lean（以及现代类型论）强制规定：
<strong>容器必须比它里面的东西高一级。</strong></p><ul><li><code>Nat</code> 在 <code>Type 0</code> 里。</li><li>包含 <code>Nat</code> 的 <code>List</code>（作为一个类型构造器）也通常在 <code>Type 0</code> 层面操作。</li><li>但是，如果你想定义一个包含“所有类型”的列表 <code>[Nat, Bool, String]</code>，这个列表本身的类型就不能是 <code>Type 0</code> 了，它必须升级到 <code>Type 1</code>。</li></ul><hr><h3 id=4-宇宙多态-universe-polymorphism>4. 宇宙多态 (Universe Polymorphism)</h3><p>在写代码时，为了避免麻烦，我们不想为 <code>Type 0</code> 写一个 <code>List</code>，又为 <code>Type 1</code> 写一个 <code>List</code>。我们希望代码是通用的。</p><p>这就有了 <strong>宇宙变量 (Universe Variables)</strong>，通常写作 <code>u</code>, <code>v</code>。</p><p>当你查看 Lean 标准库中 <code>List</code> 的定义时，你会发现它是这样写的（简化版）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=c1>-- u 是一个占位符，可以是 0, 1, 2...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>universe</span><span class=w> </span><span class=n>u</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- List 接受一个类型 α</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 这个 α 位于宇宙 u 中 (Type u)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 返回的 List α 也位于宇宙 u 中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>inductive</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=o>(</span><span class=n>α</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Type</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=kn>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>nil</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>α</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>cons</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>α</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>List</span><span class=w> </span><span class=n>α</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这意味着：</p><ol><li>如果 <code>α</code> 是 <code>Nat</code> (Type 0)，那么 <code>List Nat</code> 也是 <code>Type 0</code>。</li><li>如果 <code>α</code> 是 <code>Type</code> (Type 1)，那么 <code>List Type</code> 就是 <code>Type 1</code>。</li></ol><p><strong>这就是“宇宙多态”：你的函数或类型可以在任意层级的宇宙上工作。</strong></p><h3 id=5-总结如何理解这张图谱>5. 总结：如何理解这张图谱</h3><p>把 Lean 的类型系统想象成一个巨大的公寓楼：</p><ul><li><p><strong>地下室 (<code>Sort 0</code> / <code>Prop</code>)</strong>：</p><ul><li>住着：<code>1=1</code>, <code>Exists x, ...</code> 等命题。</li><li>特点：这层楼也是一种类型，但这里的东西主要用于“验证”，不参与实际的“物理构建”（运行时被擦除）。</li></ul></li><li><p><strong>一楼 (<code>Sort 1</code> / <code>Type 0</code>)</strong>：</p><ul><li>住着：<code>Nat</code>, <code>String</code>, <code>Bool</code> 等常见数据类型。</li><li>这是我们写普通程序最常待的地方。</li></ul></li><li><p><strong>二楼 (<code>Sort 2</code> / <code>Type 1</code>)</strong>：</p><ul><li>住着：<code>Type 0</code> 本身，以及包含了一楼住户的那些“元类型”（比如 <code>List Type</code>）。</li></ul></li><li><p><strong>顶楼 (<code>Type u</code>)</strong>：</p><ul><li>是一个变量，允许你编写同一种逻辑，适配每一层楼。</li></ul></li></ul><p><strong>一句话心法：</strong>
当你写代码时，如果是普通数据，就在 <code>Type</code>；如果是逻辑证明，就在 <code>Prop</code>。只有当你在玩弄“类型本身”（比如写元编程，或者定义极其抽象的范畴论结构）时，才需要关心 <code>Type 1</code> 及以上的层级。</p><h2 id=讲讲tactics>讲讲tactics</h2><p>如果说“命题即类型”是 Lean 的<strong>物理定律</strong>（底层原理），那么 <strong>Tactics（策略）</strong> 就是 Lean 的<strong>工程脚手架</strong>（高层工具）。</p><p>到目前为止，我们一直在说“证明就是写程序”。但在实际数学中，直接写出那个最终的“程序（Term）”通常是非常困难且反直觉的。</p><p>Tactics 的出现，是为了让我们能用<strong>指令式</strong>的方法，一步步地指导 Lean 构造出那个复杂的证明项。</p><hr><h3 id=1-为什么我们需要-tactics>1. 为什么我们需要 Tactics？</h3><p>假设你要证明一个复杂的数学定理。</p><ul><li><p><strong>Term Mode（项模式/硬写代码）</strong>：
就像你必须一次性把整个复杂的函数体写出来，不能有任何语法错误，脑子里要以此维护所有的变量状态。这就像用汇编语言写大型软件。</p><ul><li><em>优点</em>：精确，底层。</li><li><em>缺点</em>：对于长证明，人类的大脑很难直接构造出那个嵌套了十几层的 Lambda 表达式。</li></ul></li><li><p><strong>Tactic Mode（策略模式/交互式）</strong>：
Lean 提供了一个交互环境。你不需要直接给出答案，而是告诉 Lean：“先处理这个假设”，“把那个定理套用一下”，“把等式左边化简一下”。Lean 会实时反馈你现在的状态。</p><ul><li><em>优点</em>：交互式，不仅是验证，更是<strong>辅助探索</strong>。分解问题，各个击破。</li></ul></li></ul><hr><h3 id=2-核心机制tactic-mode-是如何工作的>2. 核心机制：Tactic Mode 是如何工作的？</h3><p>在 Lean 中，当你输入关键字 <strong><code>by</code></strong> 时，你就从“写代码模式”切换到了“策略模式”。</p><h4 id=心理模型填坑游戏>心理模型：填坑游戏</h4><ol><li><p><strong>目标（Goal）</strong>：
Lean 会在这个类型的定义处挖一个<strong>坑（Hole，学名 Metavariable）</strong>。你的任务就是填上这个坑。</p></li><li><p><strong>状态（Tactic State）</strong>：
VS Code 右侧会显示当前的<strong>证明状态</strong>。它长这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>h1 : P      -- 你的手牌（上下文/假设）
</span></span><span class=line><span class=cl>h2 : P → Q
</span></span><span class=line><span class=cl>⊢ Q         -- 你的目标（要构造的类型）
</span></span></code></pre></td></tr></table></div></div><p><code>⊢</code> (Turnstile) 符号：左边是你拥有的，右边是你需要的。</p></li><li><p><strong>指令（Commands）</strong>：
你每输入一个 tactic（如 <code>intro</code>, <code>apply</code>），Lean 就会根据指令修改当前的 State，直到目标被解决。</p></li><li><p><strong>幕后（Elaboration）</strong>：
当你写完 <code>by ...</code> 块时，Lean 的编译器（Elaborator）会自动把你的这一堆指令翻译回底层的 Lambda 表达式（Term）。<strong>机器只认 Term，Tactics 是给人用的。</strong></p></li></ol><hr><h3 id=3-常见-tactics-与底层-term-的对应关系>3. 常见 Tactics 与底层 Term 的对应关系</h3><p>理解 Tactics 的最好方法，是看它们对应什么底层代码（柯里-霍华德同构的体现）。</p><p>假设我们要证明 $P \to Q \to P$。</p><h4 id=场景-1引入假设-intro>场景 1：引入假设 (<code>intro</code>)</h4><ul><li><strong>Tactic</strong>: <code>intro h</code></li><li><strong>对应 Term</strong>: Lambda 抽象 <code>fun h => ...</code></li><li><strong>作用</strong>：如果目标是 <code>P → Q</code>，<code>intro h</code> 会把 <code>P</code> 移到左边的上下文里，把目标变成 <code>Q</code>。<ul><li><em>直觉</em>：为了证明“如果 P 则 Q”，我们先假设 P 成立（记为 h），然后去证明 Q。</li></ul></li></ul><h4 id=场景-2应用定理-apply>场景 2：应用定理 (<code>apply</code>)</h4><ul><li><strong>Tactic</strong>: <code>apply f</code></li><li><strong>对应 Term</strong>: 函数调用 <code>f ?</code> (待定参数)</li><li><strong>作用</strong>：<strong>逆向推理</strong>。如果目标是 <code>Q</code>，而你有一个函数 <code>f : P → Q</code>，<code>apply f</code> 会把目标变成 <code>P</code>。<ul><li><em>直觉</em>：为了得到 Q，因为我知道 f 能推出 Q，所以我只要能搞定 f 需要的原料 P 就行了。</li></ul></li></ul><h4 id=场景-3精确匹配-exact>场景 3：精确匹配 (<code>exact</code>)</h4><ul><li><strong>Tactic</strong>: <code>exact h</code></li><li><strong>对应 Term</strong>: 直接填入值 <code>h</code></li><li><strong>作用</strong>：如果目标是 <code>P</code>，而你手头正好有一个 <code>h : P</code>，你就大喊 <code>exact h</code>，证明结束。</li></ul><h4 id=场景-4结构分解-cases--rcases>场景 4：结构分解 (<code>cases</code> / <code>rcases</code>)</h4><ul><li><strong>Tactic</strong>: <code>cases h</code></li><li><strong>对应 Term</strong>: 模式匹配 <code>match h with ...</code></li><li><strong>作用</strong>：如果你有一个“或”（$A \lor B$）或者“且”（$A \land B$）类型的假设，把它拆解开。</li></ul><hr><h3 id=4-实例演示两种模式的对比>4. 实例演示：两种模式的对比</h3><p>让我们证明：<strong>如果 P 且 Q 成立，那么 P 成立。</strong>
类型为：<code>P ∧ Q → P</code></p><h4 id=方式-aterm-mode-直接构造>方式 A：Term Mode (直接构造)</h4><p>你需要非常清楚 Pair 类型的内部结构。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=kn>example</span><span class=w> </span><span class=o>(</span><span class=n>P</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fun</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=bp>=&gt;</span><span class=w> </span><span class=n>h</span><span class=bp>.</span><span class=n>left</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 解释：这是一个匿名函数，接收 h，返回 h 的左分量</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=方式-btactic-mode-交互式>方式 B：Tactic Mode (交互式)</h4><p>这是更像“数学证明过程”的写法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-lean data-lang=lean><span class=line><span class=cl><span class=kn>example</span><span class=w> </span><span class=o>(</span><span class=n>P</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kt>Prop</span><span class=o>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=bp>∧</span><span class=w> </span><span class=n>Q</span><span class=w> </span><span class=bp>→</span><span class=w> </span><span class=n>P</span><span class=w> </span><span class=o>:</span><span class=bp>=</span><span class=w> </span><span class=k>by</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- 状态： ⊢ P ∧ Q → P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>intro</span><span class=w> </span><span class=n>h</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- 状态： h : P ∧ Q </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>--       ⊢ P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>cases</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=k>with</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=bp>|</span><span class=w> </span><span class=n>intro</span><span class=w> </span><span class=n>hp</span><span class=w> </span><span class=n>hq</span><span class=w> </span><span class=bp>=&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 状态： hp : P, hq : Q</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>--       ⊢ P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>exact</span><span class=w> </span><span class=n>hp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- 状态： No goals. 证明完成。</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>发生了什么？</strong>
Lean 实际上把你写的那堆 <code>by ...</code> 代码，悄悄编译成了：
<code>fun h => match h with | intro hp hq => hp</code>
这和方式 A 的本质是一样的，但方式 B 每一步都有提示。</p><hr><h3 id=5-高级-tactics自动化武器>5. 高级 Tactics：自动化武器</h3><p>Lean 4 的强大之处在于它不仅有手动挡（<code>intro</code>, <code>apply</code>），还有自动挡。因为 Tactics 本质上是 Lean 的元程序（Metaprograms），它们可以执行搜索算法。</p><ul><li><strong><code>rw</code> (rewrite)</strong>: 等量代换。如果你知道 <code>a = b</code>，可以用它把所有的 <code>a</code> 换成 <code>b</code>。这在底层对应复杂的等式传输原理（<code>Eq.subst</code>），手写非常痛苦，用 <code>rw</code> 极其爽快。</li><li><strong><code>simp</code> (simplify)</strong>: 简化器。它是 Lean 的扫地机器人。它有一个巨大的数据库，里面存了成千上万条化简规则（比如 <code>x + 0 = x</code>, <code>a ∧ True ↔ a</code>）。你输入 <code>simp</code>，它就自动尝试化简目标。</li><li><strong><code>linarith</code></strong>: 线性算术求解器。如果你有 <code>x &lt; y</code> 和 <code>y &lt; z</code>，目标是 <code>x &lt; z</code>，你不需要手动引用传递性，直接输入 <code>linarith</code>，它会自动搜索不等式证明。</li></ul><h3 id=6-总结如何看待-tactics>6. 总结：如何看待 Tactics</h3><ol><li><strong>思维的缓冲</strong>：Term Mode 是“自顶向下”的构造（必须先想好整体结构），Tactic Mode 允许“自底向上”或“逆向”的探索。</li><li><strong>可读性权衡</strong>：<ul><li>Term Mode 的代码短，但难懂（全是符号）。</li><li>Tactic Mode 的代码长，但记录了思维过程（先引入，再拆解，再应用&mldr;）。</li></ul></li><li><strong>Lean 4 的特色</strong>：在 Lean 4 中，Tactics 本身也是用 Lean 语言写的！这意味着你可以自己写 Tactics 来帮自己证明。</li></ol><p><strong>一句话总结：</strong>
<strong>Term 是汇编指令，Tactic 是高级语言脚本。</strong> 我们用 Tactic 指挥 Lean 去生成那些繁琐的 Term，从而完成柯里-霍华德同构要求的“构造证明值”的任务。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/lean4/>Lean4</a>
<a href=/tags/gemini/>Gemini</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=[".main-article",".widget--toc"];e.forEach(e=>{const t=document.querySelector(e);t&&renderMathInElement(t,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/lean4%E6%9E%81%E7%AE%80%E5%AF%BC%E8%AF%BB/><div class=article-image><img src=/p/lean4%E6%9E%81%E7%AE%80%E5%AF%BC%E8%AF%BB/lean4.24db2dd928861c924587b009d58ca849_hu_ac1a0c2143124fc9.png width=250 height=150 loading=lazy alt="Featured image of post Lean4极简导读" data-hash="md5-JNst2SiGHJJFh7AJ1YyoSQ=="></div><div class=article-details><h2 class=article-title>Lean4极简导读</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=heitopai/bhjiang data-repo-id=R_kgDOQSTTug data-category=Announcements data-category-id=DIC_kwDOQSTTus4CxoRP data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 滨宏</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.32.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>